\subsection{Records with overloaded fields}
\label{sec:overloaded-record-fields}

In this section we describe how the possibility of overloading symbols
without the need of declaring type classes allows record fields to be
overloaded, in an easy way. The idea is simply to transform any access
to an overloaded record field into an automatically created instance
of an undeclared type class, and similarly for any use of a record
update of an overloaded record field. 

There are certainly design decisions to be made, but below we
illustrate the proposal by creating instance of \get\_\fieldname\ and
\update\_\fieldname\ whenever there exists, respectively, an access of
and an update to an overloaded record field, where \fieldname\ is the
name of the overloaded record field.

Consider a simple example of overloaded record fields: 

\progb{\data\ \Address\ \= = \Address\ \= \{ \id\ :: \Int, \aaddress\ \= :: \String\ \= \kill
\data\ \Person\  \> = \Person\  \> \{ \id\ :: \Int, \name\     \> :: \String\ \>\}\\
\data\ \Address\ \> = \Address\ \> \{ \id\ :: \Int, \aaddress\ \> :: \String\ \>\}
}

The overloaded \id\ fields of types \Person\ and \Address\ have types:

\progb{\id\ :: \Address\ \= \kill
\id\ :: \Person\  \>$\rightarrow$ \Int\\
\id\ :: \Address\ \>$\rightarrow$ \Int
}

The following instance declarations without declared type classes can
be automatically created: 

\progb{
\get\_\id\ :: \Person\ $\rightarrow$ \Int\\
\instance\ \get\_\id\ (\Person\ \id\ \_\ )  = \id\\ \\
\get\_\id\ :: \Address\ $\rightarrow$ \Int\\
\instance\ \get\_\id\ (\Address\ \id\ \_\ ) = \id
}

If record field updating is used, updating functions are created, as
illustrated below. Consider for example that record field updating is
used as follows:

\progb{
\update\_\id\ :: \Person\ $\rightarrow$ \Int\ $\rightarrow$ \Person\\
\instance\ \update\_\id\ (\Person\ \id\ \name) \new\_\id\ = \Person\ \new\_\id\ \name\\ \\
\update\_\id\ :: \Address\ $\rightarrow$ \Int\ $\rightarrow$ \Address\\
\instance\ \update\_\id\ (\Address\ \id\ \aaddress) \new\_\id\ = \Address\ \new\_\id\ \aaddress
}

Given any expression $p$ of type \Person, any use of {\tt ($p$
  \{\id\ = \new\_\id\})} could then be translated to {\tt
  (\update\_\id\ $p$ \new\_\id)}.  Similarly, given any expression $a$
of type \Address, any use of {\tt $a\!$ \{\id\ = \new\_\id\}} could
then be translated to {\tt \update\_\id\ $a$ \new\_\id}.

