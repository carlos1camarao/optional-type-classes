\section{Related Work}
\label{sec:related-work}

Principal type schemes for overloading and subtyping were studied
since more than two decades \cite{Smith-Phd, VolpanoSmith91,
  Smith94principaltype}. These first works have proven undecidability
of unrestrictive constraint set satisfiability (CS-SAT), by a
reduction from the Post Correspondence Problem. The CS-SAT problem was
firstly defined in terms of provability in the type system.

Mark Jones defined predicate entailment as a relation, viewing CS-SAT
as a problem separated from the type system, but did not discuss
decidability \cite{MarkJones94a, SIQT}.

CS-SAT was later defined in terms of anti-unification and least common
generalisation in \cite{CS-SAT-PPDP04}, where an algorithm for testing
satisfiability used an iteration limit for termination, the limit not
being reached in practical cases. CS-SAT was restricted, using a
termination criterion based on a measure of the size of types in
constraints, to define an algorithm for CS-SAT that always terminates
\cite{JBCS-Terminating-CS-SAT}, which has been used only in a
prototype implementation (available at {\tt
  http://github.com/rodrigogribeiro/mptc}).

Constraint-handling rules (CHRs) were used to describe the programming
language Mercury, where context-dependent overloading is supported
\cite{TheoryOfOverloading}. Open-world ambiguity and FDs were defined
via CHRs in \cite{TheoryOfOverloading}, constituting the basis of
GHC's implementation.

Expression ambiguity for context-dependent overloading was firstly
presented in \cite{Solution-to-MPTC-SBLP-09}, as a proposal for the
introduction of MPTCs in Haskell without the need for FDs and type
families.  A comparison between open-world ambiguity and expression
ambiguity is presented in
\cite{JBCS-Ambiguity-and-constrained-polymorphism}.

Work on instance modularization with names given to instance
definitions was presented in \cite{Named-instances-2001}. A more
radical change to the module system of Haskell, more in the direction
of the module system of SML, was proposed in
\cite{Modular-type-classes-07}.  The subject of controlling the scope
of instances in Haskell is discussed in
\cite{Controlling-scope-instances,Extensible-superclasses-06}.
