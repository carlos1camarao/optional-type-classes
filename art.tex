\documentclass[review]{elsarticle}

\usepackage{float}
\floatstyle{boxed} 
\restylefloat{figure}

\usepackage{bussproofs}

\usepackage{amsmath,amssymb,amsthm,thmtools}
%\modulolinenumbers[5]

\journal{Science of Computer Programming}

\begin{document}

\begin{frontmatter}

\title{Optional Type Classes}

\begin{abstract}

The main motivation of this paper is to present an approach for
allowing programmers to declare and use overloaded symbols without
declaring their types in type classes. In this approach, when the type
of an overloaded symbol is not explicitly defined in a type class, it
is automatically determined from the anti-unification of instance
types defined for the symbol in the relevant module. Overloaded names
not declared in a type class have naturally thus a modular scope. The
paper also presents minimalist modifications to Haskell's module
system that allow all overloaded names to have a modular scope;
however, overloaded names with modular scope could be used together
with Haskell-style instances, which have global scope.

The paper also uses a definition of ambiguity that is different from
Haskell's, with the main motivation of allowing more flexibility to
Haskell-style of overloading. The paper illustrates the additional
flexibility obtained by showing how overloaded record fields can be
easily supported, and how type directed name resolution can be
obtained for free, by using the redefined ambiguity rule together with
overloaded names that do not need to be declared in a type class.

A type system is presented, with examples included to illustrate the
use of type system rules and the additional flexibility of overloading
obtained with the type system.

%A theorem is included that proves that unreachability of type
%variables in a constraint is a necessary and sufficient condition for
%overloading resolution of this constraint in the type system.

A type inference algorithm  %and 
% , which includes a constraint-set satisfiability function that
% restricts the constraint-set satisfiability problem in order to
% achieve decidability. The type inference algorithm describes also a
% constraint-set improvement function, for filtering out constraints
% for which overloading has been resolved, and a context-reduction
% function, for reducing constraint sets according to matching
% instances.
% a standard dictionary-style semantics
for a mini-Haskell language with
modules that can specify class and instance declarations but also
imported and exported names, overloaded or not, is presented, that is
shown to be sound and to compute principal types with respect to the
type system.
% , for which a coherence theorem is proved.

\end{abstract}

\begin{keyword}
Ambiguity; Instance modularization; Optional type classes; Constrained
polymorphism; Context-dependent overloading; Haskell
\end{keyword}

\author{Rodrigo Ribeiro}
\address{Dep. de Computa\c{c}\~ao e Sistemas, Universidade
  Federal de Ouro Preto, \newline ICEA, Jo\~ao Monlevade, Minas Gerais, Brasil}
\ead{rodrigo@decsi.ufop.br}

\author{Carlos Camar\~ao}
\address{Dep. de Ci\^encia da Computa\c{c}\~ao, Universidade Federal
  de Minas Gerais, \newline Av. Ant\^onio Carlos 6627, Belo Horizonte, Minas Gerais, Brasil}
\ead{camarao@dcc.ufmg.br}

\author{Luc\'{\i}lia Figueiredo}
\address{Dep. de Computa\c{c}\~ao, Universidade
  Federal de Ouro Preto, \newline ICEB, Campus Universit\'ario Morro do
  Cruzeiro, Ouro Preto, Minas Gerais, Brasil}
\ead{luciliacf@gmail.com}

\author{Cristiano Vasconcellos}
\address{Dep. de Ci\^encia da Computa\c{c}\~ao, Universidade do Estado de Santa Catarina (UDESC), Joinville}
\ead{cristiano.vasconcellos@udesc.br}

\end{frontmatter}

\input{command.tex}

\input{introd}
\input{preliminaries}
\input{anti-unification}
\input{ambiguity}
\input{modular-instances}
\input{optional-type-classes}
\input{examples}
\input{type-inference}
%\input{semantics}
\input{related-work}
\input{conclusion}

\appendix
%\input{entailment}
%\input{satisfiability}

\section*{References}
\bibliographystyle{elsarticle-num}
\bibliography{main}

\end{document}
