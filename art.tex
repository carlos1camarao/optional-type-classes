\documentclass{llncs}
\usepackage{amsmath,amssymb,proof}
\usepackage{makeidx}  % allows for indexgeneration
%

\usepackage[american]{babel}
\usepackage[utf8]{inputenc}

\usepackage{float}
\usepackage{amssymb}
\usepackage{color}
\usepackage{fancyhdr}
%\usepackage{minted}

\begin{document}

\input{command.tex}

\input{meta.keys}

%
\mainmatter              % start of the contributions

\title{Optional Type Classes for Haskell}

%
\author{Rodrigo Ribeiro \inst{1} \and Carlos Camar\~ao\inst{2} \and Luc\'ilia
Figueiredo\inst{3} \and Cristiano Vasconcellos\inst{4}}
\institute{DECSI, Universidade Federal de Ouro Preto (UFOP), Jo√£o Monlevade\\
\email{rodrigo@decsi.ufop.br} \and
DCC, Universidade Federal de Minas Gerais (UFMG), Belo Horizonte\\
\email{camarao@dcc.ufmg.br} \and
DECOM, Universidade Federal de Ouro Preto (UFOP), Ouro Preto\\
\email{luciliacf@gmail.com} \and
DCC, Universidade do Estado de Santa Catarina (UDESC), Joinville\\
\email{cristiano.vasconcellos@udesc.br}
}
\maketitle              % typeset the title of the contribution

\begin{abstract}

This paper explores an approach for allowing type classes to be
optionally declared by programmers, i.e. for allowing programmers to
overload symbols without having to declare the types of these symbols
in type classes.

The idea is based on defining the type of an overloaded symbol without
an annotated type as the anti-unification of instance types defined for
the symbol in a module, by automatically creating a type class with
that single overloaded name. This depends on a modularization of
instance visibility, as well as on a redefinition of Haskell's
ambiguity rule. The paper presents the modifications to Haskell's
module system that are necessary for allowing instances to have a
modular scope, based on previous work published by one of the
authors. The definition of the type of overloaded symbols as the
anti-unification of available instance types and the redefined
ambiguity rule is also based on previous works by the authors.

The added flexibility to Haskell-style of overloading is illustrated
by defining a type system and a type inference algorithm that allows
overloaded record fields.

% The redefinition of Haskell's ambiguity rule can also be used to
% address some of the issues related to type directed name resolution.

\end{abstract}

\input{introd}

\input{anti-unification}

\input{modular-instances}

% \input{ambiguity}

\input{optional-type-classes}

\input{records-with-overloaded-fields}

% \input{type-directed-named-resolution}

\input{conclusion}

\bibliographystyle{plain}
\bibliography{main}

\end{document}
