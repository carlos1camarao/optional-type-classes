\documentclass{llncs}
\usepackage{amsmath,amssymb}
\usepackage{makeidx}  % allows for indexgeneration
%

\usepackage[american]{babel}
\usepackage[utf8]{inputenc}

\usepackage{float}
\usepackage{amssymb}
\usepackage{color}
\usepackage{fancyhdr}
%\usepackage{minted}

\begin{document}

\input{command.tex}

\input{meta.keys}

%
\mainmatter              % start of the contributions

\title{Optional Type Classes for Haskell}

%
\author{Rodrigo Ribeiro \inst{1} \and Carlos Camar\~ao\inst{2} \and Luc\'ilia
Figueiredo\inst{3} \and Cristiano Vasconcellos\inst{4}}
\institute{DECSI, Universidade Federal de Ouro Preto (UFOP), Jo√£o Monlevade\\
\email{rodrigo@decsi.ufop.br} \and
DCC, Universidade Federal de Minas Gerais (UFMG), Belo Horizonte\\
\email{camarao@dcc.ufmg.br} \and
DECOM, Universidade Federal de Ouro Preto (UFOP), Ouro Preto\\
\email{luciliacf@gmail.com} \and
DCC, Universidade do Estado de Santa Catarina (UDESC), Joinville\\
\email{cristiano.vasconcellos@udesc.br}
}
\maketitle              % typeset the title of the contribution

\begin{abstract}

This paper explores an approach for allowing type classes to be
optionally declared by programmers, i.e. programmers can overload
symbols without declaring their types in type classes.

The type of an overloaded symbol is, if not explicitly defined in a
type class, automatically determined from the anti-unification of
instance types defined for the symbol in the relevant module. A type
class having the overloaded name as its unique member is automatically
created from this type.

This depends on a modularization of instance visibility, as well as on
a redefinition of Haskell's ambiguity rule. The paper presents the
modifications to Haskell's module system that are necessary for
allowing instances to have a modular scope, based on previous work by
the authors. The definition of the type of overloaded symbols as the
anti-unification of available instance types and the redefined
ambiguity rule is also based on previous works by the authors.

The added flexibility to Haskell-style of overloading is illustrated
by defining a type system and a type inference algorithm that allows
overloaded record fields.

% The redefinition of Haskell's ambiguity rule can also be used to
% address some of the issues related to type directed name resolution.

\end{abstract}

\input{introd}

\input{anti-unification}

\input{modular-instances}

% \input{ambiguity}

\input{optional-type-classes}

\input{records-with-overloaded-fields}

% \input{type-directed-named-resolution}

\input{related-work}

\input{conclusion}

\bibliographystyle{plain}
\bibliography{main}

\end{document}
