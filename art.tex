\documentclass[review]{elsarticle}

\usepackage{float}
\floatstyle{boxed} 
\restylefloat{figure}

\usepackage{bussproofs}

\usepackage{amsmath,amssymb,amsthm,thmtools}
%\modulolinenumbers[5]

\journal{Science of Computer Programming}

\begin{document}

\begin{frontmatter}

\title{Optional Type Classes}

\begin{abstract}

This paper presents an approach for allowing programmers to declare
and use overloaded symbols without declaring their types in type
classes. An overloaded symbol's type not explicitly defined in a type
class is automatically determined from the anti-unification of the
types of visible instances for this symbol in the relevant module.
Overloaded symbols not declared in a type class have thus a modular
scope.

% The paper presents minimalist modifications to Haskell's module
% system that allow all overloaded names to have a modular scope;
% however, overloaded names with modular scope could be used together
% with Haskell-style instances, which have global scope.

The approach uses an open-world approach to overloading which means:
``overloading resolution is checked when and only when there are
unreachable variables in type constraints''.

After overloading resolution is checked, either a constraint is
removed, if there is a single entailing instance for the constraint,
or else ambiguity or unsatisfiability occurs. Ambiguity means that
there are two or more instances that entail the constraint, and
unsatisfiability that there are none.

%The paper shows that ambiguity implies that there is no program
%context in which the expression could be placed so that the constraint
%could be removed.

In this approach multi-parameter type classes need not an extra
mechanism, such as functional dependencies or type families, in order
to avoid ambiguity, and the additional flexibility to Haskell-style of
overloading allows, for example, as shown in the paper, overloaded
record fields and type directed name resolution to be easily
supported.

% A type system and a type inference algorithm are presented for a
% mini-Haskell language with modules that can specify class and
% instance declarations but also imported and exported names,
% overloaded or not.  The type inference algorithm is shown to be
% sound and to compute principal types with respect to the type
% system.

% and , which includes a constraint-set satisfiability function that
% restricts the constraint-set satisfiability problem in order to
% achieve decidability. The type inference algorithm describes also a
% constraint-set improvement function, for filtering out constraints
% for which overloading has been resolved, and a context-reduction
% function, for reducing constraint sets according to matching
% instances.  a standard dictionary-style semantics

% , for which a coherence theorem is proved.

\end{abstract}

\begin{keyword}
Ambiguity; Instance modularization; Optional type classes; Constrained
polymorphism; Context-dependent overloading; Haskell
\end{keyword}

\author{Rodrigo Ribeiro}
\address{Dep. de Computa\c{c}\~ao e Sistemas, Universidade
  Federal de Ouro Preto, \newline ICEA, Jo\~ao Monlevade, Minas Gerais, Brasil}
\ead{rodrigo@decsi.ufop.br}

\author{Carlos Camar\~ao}
\address{Dep. de Ci\^encia da Computa\c{c}\~ao, Universidade Federal
  de Minas Gerais, \newline Av. Ant\^onio Carlos 6627, Belo Horizonte, Minas Gerais, Brasil}
\ead{camarao@dcc.ufmg.br}

\author{Luc\'{\i}lia Figueiredo}
\address{Dep. de Computa\c{c}\~ao, Universidade
  Federal de Ouro Preto, \newline ICEB, Campus Universit\'ario Morro do
  Cruzeiro, Ouro Preto, Minas Gerais, Brasil}
\ead{luciliacf@gmail.com}

\author{Cristiano Vasconcellos}
\address{Dep. de Ci\^encia da Computa\c{c}\~ao, Universidade do Estado de Santa Catarina (UDESC), Joinville}
\ead{cristiano.vasconcellos@udesc.br}

\end{frontmatter}

\input{command.tex}

\input{introd}
\input{preliminaries}
\input{anti-unification}
\input{ambiguity}
\input{modular-instances}
\input{optional-type-classes}
\input{examples}
\input{type-inference}
%\input{semantics}
\input{related-work}
\input{conclusion}

\appendix
%\input{entailment}
%\input{satisfiability}

\section*{References}
\bibliographystyle{elsarticle-num}
\bibliography{main}

\end{document}
