\section{Modularization of Instances}
\label{sec:modular-instances}

This paper does not attempt to discuss any major revision to Haskell's
module system. We summarize in subsection
\ref{subsec:instance-visibility-control} the work, presented in
\cite{Controlling-scope-instances}, that allows a modular control of
the visibility of instance definitions. This has the additional
benefit of enabling type classes to be optionally declared by
programmers, by the introduction of a single additional rule (to
account for the possibility of type classes to be declared or not):

\begin{definition}[Type of overloaded variable]

If the type of an overloaded variable (i.e.~a variable that is
introduced in an instance definition) is not explicitly annotated in a
type class declaration, then the variable's type is the
anti-unification of instance types defined for the variable in the
current module; otherwise, it is the annotated type.

\label{overloaded-variable-type}
\end{definition}

Instance modularization and the rule of expression ambiguity, that
considers the context where an expression occurs to detect whether an
expression is ambiguous or not, has profound consequences. Consider,
for example:

\proga{xx\=\kill
\module\ $A$ where\+\\
  \class\ \SShow\ $t$ \ldots\\
  \class\ \RRead\ $t$ \ldots\\
  \instance\ \SShow\ \Int\ \ldots\\
  \instance\ \RRead\ \Int\ \ldots\\
  $f$ = \sshow $\:$.$\:$\rread\-\\ \\

\module\ $B$ \where\+\\
  \import\ $A$\\
  \instance\ \RRead\ \Bool\ \ldots\\
  \instance\ \SShow\ \Bool\ \ldots\\
  $g$ = $f$ "True"
}

The definition of $f$ in module $A$ is well-typed, because constraints
(\SShow\ $a$, \RRead\ $a$) can be removed; this occurs because there
exists a single instance, in module $A$, for each constraint, that
entails it. As a result, $f$ has type \String $\rightarrow$
\String. Its use in module $B$ is (then) also well-typed.

That means: $f$'s semantics is a function that receives a value of
type \String\ and returns a value of type \String, according to the
definition of $f$ given in module $A$. The semantics of an expression
involves passing a (dictionary) value that is given in the context of
usage if, {\em and only if}, the expression has a constrained type.

\subsection{Instance visibility control: a summary}
\label{subsec:instance-visibility-control}

Modularization of instance definitions is allowed by means of the
importation and exportion of instances as shown in
\cite{Controlling-scope-instances}. Essentially, import and export
clauses can specify, instead of just names, occurrences of {\tt
  instance $A$ $\overline{\tau}$}, where $\overline{\tau}$ is a
(non-empty) sequence of types and $A$ is a class name.  We have:

  \[ \text{\module\ $M$ (\instance\ $A$ $\overline{\tau}$ \where\ \ldots)} \]
specifies that the instance of $\overline{\tau}$ for class $D$ is
exported in module $M$.

  \[ \text{\import\ $M$ (\instance\ $A$ $\overline{\tau}$)} \]
specifies that the instance of $\overline{\tau}$ for class $A$ is
imported from $M$, in the module where the import clause occurs.

Alternatively could simply give a name to an instance, in an instance
declaration, and use that name in import and export clauses (see
\cite{Controlling-scope-instances}).

\subsection{Pros and Cons of Instance Modularization}

Among the advantages of this simple change, we cite (following
\cite{Controlling-scope-instances}):

\begin{itemize}

  \item programmers have better control of which entities are
    necessary and should be in the scope of each module in a program;

  \item it is possible to define and use more than one instance for
    the same type in a program;

  \item problems with orphan instances (i.e.~instances defined in a
    module where neither the definition of the data type nor the
    definition of the type class) do not occur (for example, distinct
    instances of \Either\ for class \Monad, say one from package
    \mtl\ and another from \transformers, can be used in a program);

  \item the introduction of newtypes, as well as the use of functions
    that include additional (-by) parameters, such as e.g.~the (first)
    parameter of function \sortBy\ in module \Data.\List\ can be
    avoided.

\end{itemize}

With instance modularization, programmers need to be aware of which
entities are exported and imported (i.e.~which entities are visible in
the scope of a module) and their types, in particular if they are
overloaded or not.  A simple change like a type annotation for a
variable exported from a module, can lead to a change in the semantics
of using this variable in another module.

% The change is very significant if the type annotation instantiates
% the type of $x$ so that overloading of $x$ is resolved in $A$, since
% this leads to a change in the type (and meaning) of $x$ in module
% $B$.





