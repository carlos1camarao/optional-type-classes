\section{Modularization of Instances}
\label{sec:modular-instances}

This paper does not attempt to discuss any major revision to Haskell's
module system. We summarize in subsection
\ref{subsec:instance-visibility-control} the work, presented in
\cite{Controlling-scope-instances}, that allows a modular control of
the visibility of instance definitions. This has the additional
benefit of enabling type classes to be optionally declared by
programmers, by the introduction of a single additional rule (to
account for the possibility of type classes to be declared or not):

\begin{definition}[Type of overloaded variable]

If the type of an overloaded variable --- i.e.~a variable that is
introduced in an instance definition --- is not explicitly annotated
in a type class declaration, then the variable's type is the
anti-unification of instance types defined for the variable in the
current module; otherwise, it is the annotated type.

\label{overloaded-variable-type}
\end{definition}

Instance modularization and the rule of expression ambiguity, that
considers the context where an expression occurs to detect whether an
expression is ambiguous or not, has profound consequences. Consider,
for example:

\proga{xx\=\kill
\module\ $A$ where\+\\
  \class\ \SShow\ $t$ \ldots\\
  \class\ \RRead\ $t$ \ldots\\
  \instance\ \SShow\ \Int\ \ldots\\
  \instance\ \RRead\ \Int\ \ldots\\
  $f$ = \sshow $\:$.$\:$\rread\-\\ \\

\module\ $B$ \where\+\\
  \import\ $A$\\
  \instance\ \RRead\ \Bool\ \ldots\\
  \instance\ \SShow\ \Bool\ \ldots\\
  $g$ = $f$ "123"
}

In our approach (i.e.~considering ambiguity as a property of an
expression, not of a type), the definition of $f$ in module $A$ is
well-typed (it is not well-typed in Haskell), because constraints
(\SShow\ $a$, \RRead\ $a$) can be removed (in Haskell, type {\tt
  (\SShow\ $a$, \RRead\ $a$) $\Rightarrow$ \String} is ambiguous); the
constraints can be removed because there exists a single instance, in
module $A$, for each constraint, that entails it. As a result, $f$ has
type \String $\rightarrow$ \String. Its use in module $B$ is (then)
also well-typed. That means: $f$'s semantics is a function that
receives a value of type \String\ and returns a value of type \String,
according to the definition of $f$ given in module $A$. The semantics
of an expression involves passing a (dictionary) value that is given
in the context of usage if, {\em and only if}, the expression has a
constrained type.

\subsection{Instance visibility control: a summary}
\label{subsec:instance-visibility-control}

Modularization of instance definitions can be allowed as shown in
\cite{Controlling-scope-instances}. Essentially, import and export
clauses can specify, instead of just names, also {\tt instance $A$
  $\overline{\tau}$}, where $\overline{\tau}$ is a (non-empty)
sequence of types and $A$ is a class name; we have that:

  \[ \text{\module\ $M$ (\instance\ $A$ $\overline{\tau}$, \ldots) \where\ \ldots} \]
specifies that the instance of $\overline{\tau}$ for class $D$ is
exported in module $M$.

  \[ \text{\import\ $M$ (\instance\ $A$ $\overline{\tau}$, \ldots)} \]
specifies that the instance of $\overline{\tau}$ for class $A$ is
imported from $M$, in the module where the import clause occurs.

Alternatively, we can simply give a name to an instance, in an
instance declaration, and use that name in import and export clauses
(see \cite{Controlling-scope-instances}). However, in this paper we
don't need to give a name to an instance, since we only consider
instances of undeclared classes, which have a single member, and we
can thus use the name of the member as the instance name. 

%For example, 
%we can have:
%  \progb{
%   \instance\ $x$ = '1';\\
%   \instance\ $x$ = \True;
%  }    

\subsection{Pros and Cons of Instance Modularization}

Among the advantages of this simple change, we cite (following
\cite{Controlling-scope-instances}):

\begin{itemize}

  \item Programmers have better control of which entities are
    necessary and should be in the scope of each module in a program.

  \item It is possible to define and use more than one instance for
    the same type in a program.

  \item Problems with orphan instances do not occur (orphan instances
    are instances defined in a module where neither the definition of
    the data type nor the definition of the type class occur). For
    example, distinct instances of \Either\ for class \Monad, say one
    from package \mtl\ and another from \transformers, can be used in
    a program.

  \item The introduction of newtypes, as well as the use of functions
    that include additional (-by) parameters, such as e.g.~the (first)
    parameter of function \sortBy\ in module \Data.\List\ can be
    avoided.

\end{itemize}

With instance modularization, programmers need to be aware of which
entities are exported and imported --- i.e.~which entities are visible
in the scope of a module --- {\em and their types}, in particular
whether they are or not overloaded. A simple change like a type
annotation for a variable exported from a module, can lead to a change
in the semantics of using this variable in another module.

% The change is very significant if the type annotation instantiates
% the type of $x$ so that overloading of $x$ is resolved in $A$, since
% this leads to a change in the type (and meaning) of $x$ in module
% $B$.





