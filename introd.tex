\section{Introduction}
\label{sec:intro}

This paper proposes an approach for allowing symbols to be overloaded
in Haskell without explicitly declaring their types in type
classes. For this, modifications to Haskell's module system are
required so that instances have a modular scope, as well as a
redefinition of Haskell's ambiguity rule.

The proposed approach is based on the following ideas:

\begin{enumerate}

 \item As usual, the type of an overloaded symbol is a constrained
   type of the form $\forall \overline{a}.\,C \Rightarrow \tau$, where
   $C$ is a set of constraints and $\tau$ is a simple type; a
   constraint is a class name followed by a sequence of type
   variables.

\item An overloaded symbol $x$ can be defined by instance declarations
  of the form $\instance\ x=e$, without explicitly declaring its type
  in a type class.

\item The type of $x$ is automatically determined from the
  anti-unification of the instance types for $x$ that are visible in
  the relevant module, by creating a type class with a single member
  ($x$). The algorithm used for computing the type of $x$ is presented
  in Section~\ref{sec:anti-unif}.

\item Simple modifications to Haskell's module system are required so
  that instances have a modular scope. This is based on previous work
  by the authors which is summarized in
  Section~\ref{sec:modular-instances}.

\item Also, a redefinition of Haskell's ambiguity rule is required, as
  discussed in Section~\ref{sec:ambiguity}.

\end{enumerate}

The proposed approach is formalized in
Section~\ref{Optional-type-classes}, where a type system for a
core-Haskell language where type classes can be optionally declared is
presented. Modularized instance scopes with a revised ambiguity rule
and optional type classes may also avoid the use of qualified imports
(as used e.g.~in the {\em classy-prelude}, used in e.g.~Yesod
\cite{Yesod}).

The added flexibility to Haskell-style of overloading is illustrated
by presenting a simple implementation for overloaded record fields
based on the proposed approach (cf.~Section
\ref{sec:overloaded-record-fields}).

Related work is discussed in Section \ref{sec:related-work} and
Section \ref{sec:conclusion} concludes.

A prototype implementation of a type inference algorithm for Haskell supporting
overloading without the need of defining a type class is available~\cite{opt-rep}
