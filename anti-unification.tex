\section{Anti-unification of instance types}
\label{sec:anti-unif}

A type $\tau$ is a generalization of a set of simple types
$\overline{\tau}^{\,n}$ if there exist substitutions
$\overline{\phi}^{\,n}$ such that $\phi_i(\tau)=\tau_i$, for
$i=1,\ldots,n$. A generalization is also called a (first-order) {\em
  anti-unification\/} \cite{ModelTheory2012}.

We say that $\tau'$ is less general than $\tau$, written $\tau \leq
\tau'$, if there exist $\phi$ such that $\phi(\tau) = \tau'$.

The {\it least common generalization} (lcg) of a set of types
$\mathbb{T}$ and a type $\tau$ holds, written as
$\lcgR(\mathbb{T},\tau)$, if, for all generalizations $\tau'$ of
$\mathbb{T}$, we have $\tau \leq \tau'$.

An algorithm for computing the lcg of a finite set of types in
presented in Figure \ref{fig:lcg}. The concept was studied by Gordon
Plotkin \cite{plotkin1970note,plotkin1971further}, that defined a
function for constructing a generalization of two symbolic
expressions.  In Figure~\ref{fig:lcg}, we present function \lcg, that
gives the lcg of a finite set of simple types by recursion on the
structure of set $\mathbb{T}$, using a function to compute the
generalization of two simple types. For two types $\tau_1$ and
$\tau_2$ the idea is to recursively traverse the structure of both
types using a finite map to store previously generalized
types. Whenever we found two different type constructors, we search on
the finite map if they have been previously generalized. If this was
the case, the generalization is returned. But if these two type
constructors aren't in the finite map we insert them using a fresh
type variable as their generalization and return this new variable.

\begin{figure*}[ht]
	\[\progfig{
            $\lcg(\mathbb{T})=\tau$ $\:\:\:$ where 
               $(\tau, \phi)=\lcg'(\mathbb{T},\id)$, for some  $\phi$ \\ \\
            $\lcg'(\{\tau\},\phi) = (\tau, \phi)$  \\ \\		
            $\lcg'(\{\tau_1\} \cup \mathbb{T}, \phi) = \lcg''(\tau_1, \tau',\phi') \:\:\:$ where
		$\begin{array}[t]{ll}
                   (\tau',\phi')  & = lcg'(\mathbb{T}, \phi)
		\end{array}$  \\ \\		
            xxx\=xxx\=xxx\=xxx\=xxxxx\=xxxxxx\=xxxxxxxx\= \kill
            $\lcg'' (C \: \overline{\tau}^{\,n},\:  D\: \overline{\rho}^{\,m},\phi)=$\+\\
              \textbf{if}\ $\phi(\alpha)=( C\:\overline{\tau}^{\,n},\: D\:\overline{\rho}^{\,m})$
                      for some $\alpha$ \textbf{then}\ $(\alpha,\phi)$ \\
              \textbf{else} \+\\
              \textbf{if}\ $n\not=m$ \textbf{then}\
                 $(\beta, \phi [\beta \mapsto ( C \:\overline{\tau}^{\,n},\: D\:\overline{\rho}^{\,m})])$ \+ \\
		 where $\beta$ is a fresh type variable \-\\[.1cm]
              \textbf{else}\ $(\psi\: \overline{\tau'}^{\,n}, \phi_n)$\+\\
                 where $\begin{array}[t]{l}
		          (\psi,\phi_0) = \left\{\begin{array}{ll}
                                            (C ,\phi) & \textbf{if } C = D \\
                                            (\alpha, \phi\,[\alpha\mapsto (C, D)])
                                                      & \text{otherwise, $\alpha$ is fresh }\\
                                          \end{array}\right. \\[.3cm]
                          (\tau'_i,\phi_i) = lcg''(\tau_i, \rho_i, \phi_{i-1}), \text{ for } i=1, \ldots, n
                        \end{array}$ \-\-\-	
        }
        \]
\caption{Least Common Generalization} \label{fig:lcg}
\end{figure*}
As an example of the use of \lcg, consider the following types (of
functions \map\ on lists and trees, respectively):

\progb{
   $(a \rightarrow b)$ $\rightarrow$ [$a$] $\rightarrow$ [$b$]\\
   $(a \rightarrow b)$ $\rightarrow$ \Tree\ $a$ $\rightarrow$ \Tree\ $b$
}

A call of \lcg\ for a set with these types yields type $(a \rightarrow
b) \rightarrow c\:\: a \rightarrow c\:\: b$, where $c$ is a
generalization of type constructors {\tt []} and \Tree.

We have: 

\begin{Theorem}[Soundness of \lcg]
For all (sets of simple types) $\mathbb{T}$, we have that
$\lcg(\mathbb{T})$ yields a generalization of $\mathbb{T}$.
\label{theorem:lcg-is-sound}
\end{Theorem}

\begin{Theorem}[Completeness of \lcg]
For all (sets of simple types) $\mathbb{T}$, we have that
$\lcgR(\mathbb{T},\lcg(\mathbb{T}))$ holds, i.e.~if $\tau$ is a
generalization of $\mathbb{T}$ then $\lcg(\mathbb{T}) \leq \tau$.
\label{theorem:lcg-is-complete}
\end{Theorem}

\begin{Theorem}[Compositionality of \lcg]
For all non-empty (sets of simple types) $\mathbb{T}, \mathbb{T'}$, we
have that $\lcg(\lcg(\mathbb{T}),\lcg(\mathbb{T'})) = \lcg(\mathbb{T}
\cup \mathbb{T'})$.
\label{theorem:lcg-is-compositional}
\end{Theorem}

\begin{Theorem}[Uniqueness of \lcg]
For all (sets of simple types) $\mathbb{T}$, we have that
$\lcg(\mathbb{T})$ is unique, up to variable renaming.
\label{theorem:lcg-is-unique-modulo-variable-renaming}
\end{Theorem}



The proofs use straighforward induction on the number and complexity
of elements of $\mathbb{T}$.


