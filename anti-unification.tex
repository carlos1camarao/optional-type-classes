\section{Preliminaries}\label{prelimirares}

In this section we introduce some basic definitions and notations. We
consider that meta-variables defined can appear primed or subscripted.

Meta-variable usage is defined in the paper as follows: $x,y$ denote
term variables, $\alpha, \beta$ ($a, b,...$
in examples) type variables, $e$ a term,
$\tau,\rho$ simple types, $\sigma$ a type, $\Gamma$ a typing context, 
that is, a set of pairs written as $x:\sigma$, and $S$ a
substitution. A constraint is formed by a pair of a class name $C$ and
a sequence of types $\overline{\tau}$. We slighly abuse notation and 
use $\kappa$ to denote both a single constraint and a constraint set.

The notation $\overline{a}^{\,n}$, or simply $\overline{a}$, denotes
the sequence $a_1 \cdots a_n$, or $a_1, \ldots, a_n$, or
$a_1;\ldots;a_n$, depending on the context where it is used, where
$n\geq 0$. When used in a context of a set, it denotes the
corresponding set of elements in the sequence $\{a_1,\ldots,a_n\}$. It
can be used with more than one variable; for example, in $\overline{x
  = e}^{\,n}$, it denotes the sequence $x_1 = e_1, \ldots, x_n = e_n$.

A substitution is a function from type variables to simple type
expressions (cf.~Section \ref{Optional-type-classes}). The identity
substitution denoted by \id. $\phi(\sigma)$ (or simply $\phi\,\sigma$)
represents the capture-free operation of substituting $\phi(\alpha)$
for each free occurrence of $\alpha$ in $\sigma$.

We overload the substitution application on constraints, constraint
sets and sets of types. Definition of application on these elements is
straightforward. The symbol $\circ$ denotes function composition and
$\dom{\phi}=\{\alpha \mid\ \phi(\alpha) \neq \alpha\}$.

The notation $\phi[\overline{\alpha}\mapsto\overline{\tau}]$ denotes
the updating of $\phi$ such that $\overline{\alpha}$ maps to
$\overline{\tau}$, that is, the substitution $\phi'$ such that
$\phi'(\beta) = \tau_i$ if $\beta = \alpha_i$, for $i = 1,...,n$,
otherwise $\phi(\beta)$. Also, $[\overline{\alpha}\mapsto\overline{\tau}]
= \id[\overline{\alpha}\mapsto\overline{\tau}]$.

\subsection{Anti-unification of instance types}
\label{sec:anti-unif}

A type $\tau$ is a generalization of a set of simple types
$\overline{\tau}^{\,n}$ if there exist substitutions
$\overline{\phi}^{\,n}$ such that $\phi_i(\tau)=\tau_i$, for
$i=1,\ldots,n$. A generalization is also called a (first-order) {\em
  anti-unification\/} \cite{ModelTheory2012}.

We say that $\tau'$ is less general than $\tau$, written $\tau \leq
\tau'$, if there exist $\phi$ such that $\phi(\tau) = \tau'$.

The {\it least common generalization} (lcg) of a set of types
$\mathbb{T}$ and a type $\tau$ holds, written as
$\lcgR(\mathbb{T},\tau)$, if, for all generalizations $\tau'$ of
$\mathbb{T}$, we have $\tau \leq \tau'$.

An algorithm for computing the lcg of a finite set of types in
presented in Figure \ref{fig:lcg}. The concept was studied by Gordon
Plotkin \cite{plotkin1970note,plotkin1971further}, that defined a
function for constructing a generalization of two symbolic
expressions.  In Figure~\ref{fig:lcg}, we present function \lcg, that
gives the lcg of a finite set of simple types by recursion on the
structure of set $\mathbb{T}$, using a function to compute the
generalization of two simple types. For two types $\tau_1$ and
$\tau_2$ the idea is to recursively traverse the structure of both
types using a finite map to store previously generalized
types. Whenever we found two different type constructors, we search on
the finite map if they have been previously generalized. If this was
the case, the generalization is returned. But if these two type
constructors aren't in the finite map we insert them using a fresh
type variable as their generalization and return this new variable.

\begin{figure*}[ht]
	\[\progfig{
            $\lcg(\mathbb{T})=\tau$ $\:\:\:$ where 
               $(\tau, \phi)=\lcg'(\mathbb{T},\id)$, for some  $\phi$ \\ \\
            $\lcg'(\{\tau\},\phi) = (\tau, \phi)$  \\ \\		
            $\lcg'(\{\tau_1\} \cup \mathbb{T}, \phi) = \lcg''(\tau_1, \tau',\phi') \:\:\:$ where
		$\begin{array}[t]{ll}
                   (\tau',\phi')  & = lcg'(\mathbb{T}, \phi)
		\end{array}$  \\ \\		
            xxx\=xxx\=xxx\=xxx\=xxxxx\=xxxxxx\=xxxxxxxx\= \kill
            $\lcg'' (C \: \overline{\tau}^{\,n},\:  D\: \overline{\rho}^{\,m},\phi)=$\+\\
              \textbf{if}\ $\phi(\alpha)=( C\:\overline{\tau}^{\,n},\: D\:\overline{\rho}^{\,m})$
                      for some $\alpha$ \textbf{then}\ $(\alpha,\phi)$ \\
              \textbf{else} \+\\
              \textbf{if}\ $n\not=m$ \textbf{then}\
                 $(\beta, \phi [\beta \mapsto ( C \:\overline{\tau}^{\,n},\: D\:\overline{\rho}^{\,m})])$ \+ \\
		 where $\beta$ is a fresh type variable \-\\[.1cm]
              \textbf{else}\ $(\psi\: \overline{\tau'}^{\,n}, \phi_n)$\+\\
                 where $\begin{array}[t]{l}
		          (\psi,\phi_0) = \left\{\begin{array}{ll}
                                            (C ,\phi) & \textbf{if } C = D \\
                                            (\alpha, \phi\,[\alpha\mapsto (C, D)])
                                                      & \text{otherwise, $\alpha$ is fresh }\\
                                          \end{array}\right. \\[.3cm]
                          (\tau'_i,\phi_i) = lcg''(\tau_i, \rho_i, \phi_{i-1}), \text{ for } i=1, \ldots, n
                        \end{array}$ \-\-\-	
        }
        \]
\caption{Least Common Generalization} \label{fig:lcg}
\end{figure*}
As an example of the use of \lcg, consider the following types (of
functions \map\ on lists and trees, respectively):

\progb{
   $(a \rightarrow b)$ $\rightarrow$ [$a$] $\rightarrow$ [$b$]\\
   $(a \rightarrow b)$ $\rightarrow$ \Tree\ $a$ $\rightarrow$ \Tree\ $b$
}

A call of \lcg\ for a set with these types yields type $(a \rightarrow
b) \rightarrow c\:\: a \rightarrow c\:\: b$, where $c$ is a
generalization of type constructors {\tt []} and \Tree.

We have: 

\begin{Theorem}[Soundness of \lcg]
For all (sets of simple types) $\mathbb{T}$, we have that
$\lcg(\mathbb{T})$ yields a generalization of $\mathbb{T}$.
\label{theorem:lcg-is-sound}
\end{Theorem}

\begin{Theorem}[Completeness of \lcg]
For all (sets of simple types) $\mathbb{T}$, we have that
$\lcgR(\mathbb{T},\lcg(\mathbb{T}))$ holds, i.e.~if $\tau$ is a
generalization of $\mathbb{T}$ then $\lcg(\mathbb{T}) \leq \tau$.
\label{theorem:lcg-is-complete}
\end{Theorem}

\begin{Theorem}[Compositionality of \lcg]
For all non-empty (sets of simple types) $\mathbb{T}, \mathbb{T'}$, we
have that $\lcg(\lcg(\mathbb{T}),\lcg(\mathbb{T'})) = \lcg(\mathbb{T}
\cup \mathbb{T'})$.
\label{theorem:lcg-is-compositional}
\end{Theorem}

\begin{Theorem}[Uniqueness of \lcg]
For all (sets of simple types) $\mathbb{T}$, we have that
$\lcg(\mathbb{T})$ is unique, up to variable renaming.
\label{theorem:lcg-is-unique-modulo-variable-renaming}
\end{Theorem}



The proofs use straighforward induction on the number and complexity
of elements of $\mathbb{T}$.


